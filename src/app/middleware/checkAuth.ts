/* eslint-disable @typescript-eslint/no-explicit-any */
import { NextFunction, Request, Response } from "express";
import { Role, UserStatus } from "../../generated/prisma/enums";
import { cookieUtils } from "../utils/cookies";
import { prisma } from "../lib/prisma";
import AppError from "../errorHelpers/AppError";
import status from "http-status";
import { jwtUtils } from "../utils/jwt";
import { envVars } from '../config/env';

export const checkAuth = (...authRoles: Role[]) => async (req: Request, res: Response, next: NextFunction) => {
    try {
        // session token verification
        const sessionToken = cookieUtils.getCookie(req, "better-auth.session_token");
        if (!sessionToken) {
            throw new Error("Unauthorized: No session token provided");
        }
        const sessionExists = await prisma.session.findFirst({
            where: {
                token: sessionToken,
                expiresAt: {
                    gt: new Date(),
                },
            },
            include: {
                user: true,
            }
        });
        if (sessionExists && sessionExists.user) {
            const user = sessionExists.user;
            const now = new Date();
            const expiresAt = new Date(sessionExists.expiresAt);
            const createdAt = new Date(sessionExists.createdAt);

            const sessionLifeTime = expiresAt.getTime() - createdAt.getTime();
            const timeRemaining = expiresAt.getTime() - now.getTime();
            const percentageTimeRemaining = (timeRemaining / sessionLifeTime) * 100;

            if (percentageTimeRemaining < 20) {
                res.setHeader("X-Session-Refresh", "true");
                res.setHeader("X-Session-Expires-At", expiresAt.toISOString());
                res.setHeader("X-Time-Remaining", timeRemaining.toString());

                console.log("Session Expiring Soon!!!")
            }

            if (user.status === UserStatus.BLOCKED || user.status === UserStatus.DELETED) {
                throw new AppError(status.FORBIDDEN, "Unauthorized: User is not active");
            }
            if (user.isDeleted) {
                throw new AppError(status.FORBIDDEN, "Unauthorized: User is deleted");
            }
            if (authRoles.length > 0 && !authRoles.includes(user.role as Role)) {
                throw new AppError(status.FORBIDDEN, "Unauthorized: You don't have permission to access this resource");
            }
        }

        // access token verification
        const accessToken = cookieUtils.getCookie(req, "accessToken");
        if (!accessToken) {
            throw new AppError(status.UNAUTHORIZED, "Unauthorized: No access token provided");
        }
        const verifiedToken = jwtUtils.verifyToken(accessToken, envVars.ACCESS_TOKEN_SECRET);
        if (!verifiedToken.success) {
            throw new AppError(status.UNAUTHORIZED, "Unauthorized: Invalid access token");
        }
        if (authRoles.length > 0 && !authRoles.includes(verifiedToken.data!.role as Role)) {
            throw new AppError(status.FORBIDDEN, "Unauthorized: You don't have permission to access this resource");
        }
        next();
    } catch (error: any) {
        next(error);
    }
};